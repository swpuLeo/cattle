/* 思路：此题由于对阶梯限制特殊第K行就有K枚硬币，所以第K行一共消耗的硬币数量由等差数列公式可以得到为k*(k + 1) / 2，我们有n枚硬币构建阶梯所需硬币必须小于我们有的即:
k * (k + 1) / 2 <= n = 》k ^ 2 + k - 2n <= 0对于这个以k为自变量的函数，我们要求k能取得的最大值同时满足这个不等式，根据二次函数根k = (sqrt(1 + 8n) - 1) / 2, 
所以只需要返回(sqrt(1 + 8n) - 1) / 2即可，唯一需要注意的是1 / 4 = 0而不是0.25，因为机器内部不会帮助进行一个转化的应该是1.0 / 4在c++中，机器从左至右进行读，
当读到某个值为浮点型的时候就会把后面的（括号中的）都自动强转为浮点型。*/
class Solution {
public:
	int arrangeCoins(int n) {
		return  int(sqrt(1.0 / 4 + 2 * n) - 1.0 / 2);
	}
};