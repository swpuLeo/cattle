/* 思路：此题本质就是在一个有序数组中寻找某个符合我们条件的值，搜索的方法有很多，但是对于在有序数组中，最有效的就是二分搜索法，
二分搜索法就是我们不断找数组中点来进行比较，如果中点过大了，那么我们就把数组去除掉后面一半，如果中点过小，就把数组去除掉前面一半，
这样每次寻找我们都去除掉一半数字，就可以极快的找到目标值（这里的去掉也不是真的删除而是变化前后索引的范围好像是删除了一样），
同时对于此题与实际的二分搜索法有所区别的是我们找到版本错误的不能马上返回，因为我们找的是第一个出现错误的，所以我们不能保证前面没有出现错误的，
所以找到出现错误的以后我们就应该去掉后面的一半（找第一个出现错误的版本，后面没有用），如果找到的是没有出现错误的，那么出现错误的一定在后面所以要舍去前面一半。*/
class Solution {
public:
	int firstBadVersion(int n) {
		int low = 1;
		int high = n;
		int mid = n;
		while (low < high)
		{
			mid = low + (high - low) / 2;
			if (isBadVersion(mid))
				high = mid;
			else low = mid + 1;
		}
		return high;
	}
};