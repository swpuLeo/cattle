/* 思路1：此题可以近似看成一个求26进制的题，但是值得注意的是对于26的整数倍，
如果我们不加以限制的话就会造成A0的情况出现，而题目给出的条件中是不考虑这种情况的。
所以我们只需要排除这种情况对于任何26的整数倍，我们就直接先插入‘Z’，同时还要对原数进行减一的操作。
因为如果不进行减一的话对于26所对应的就是AZ（其实就是为了将A0映射为Z要对A0整体减一，由于0 - 1不够，
所以要向A借一位，所以最后就得到了Z。所以我们要插入Z之后再对原数减1。）*/
class Solution {
public:
	string convertToTitle(int n) {
		string res;
		int temp = 0;
		while (n != 0)
		{
			temp = n % 26;
			if (temp == 0)
			{
				res = 'Z' + res;
				n--;
			}
			else
				res = (char)(temp + 'A' - 1) + res;
			n = n / 26;
		}
		return res;
	}
};

/* 思路2：上一种思路我们看到了为什么对于26的整数倍要进行减一的操作，同时对于1 - 25而言，
我们应该映射到A - Y，但是对于1我们直接加上A的ascii码就会得到B，
所以我们也要进行减一的操作，(char)(temp + 'A' - 1)。对于Z我们需要减一，对于A - Y也需要减一，
如果我们可以减这两种减一统一起来事情就变得简单了。所以我们可以考虑在取余之前就整体减一。
我们可以证明对于26的N倍（num % 26 = N），我们整体减一在取余就会得到(num - 1) % 26 = N - 1余25，
所以25直接加上A的ASCII码就得Z，所以对于Z而言是可以提前减一的。对于A - Y而言num % 26 = N余t，
t属于1到25的范围。这个t减一在加上'A'的ASCII码就对于与A - Y（t + 'A' - 1），
而如果我们提前减一的话这个表达式就变成了(num - 1) % 26 = N余t - 1;
最后我们的到的值就不用进行减一操作（t - 1 + 'A'）。所以可以将Z和A - Y的操作统一起来了，提前减一，
然后再正常取模即可。*/
class Solution {
public:
	string convertToTitle(int n) {
		string res;
		int temp = 0;
		while (n != 0)
		{
			n--;
			temp = n % 26;
			res = (char)(temp + 'A') + res;
			n = n / 26;
		}
		return res;
	}
};
