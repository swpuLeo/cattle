/* 思路：此题又是一道映射题，由于我们需要统计每个字符出现的次数，所以映射关系就为字符->个数，所以，只需要先遍历一遍统计字符个数，再遍历一遍从头到尾在map中去找，
每遍历一个就对其个数减一，如果谁的个数小于0，则就是多出来的。对于字符而言的映射表，我们不需要使用map，我们还可以直接使用一个int型大小为255(也可以只用26为，
因为只有字母，但是需要每次操作转换一下即可)数组来充当map, 每个字符都是有Ascii码（0 - 255)所以一个255大小的数组就可以表示完所有字符，我们直接用字符作为下标即可
（字符其实本质也是一种整数，只是我们规定某些不同的整数如果声明为char的话就代表着不同的意思），每个不同字符对于的整数都不一样，所以可以这样操作。同时有个小技巧就是，
int * map = new int[255](); 我们在用new创建数组的时候可以在后面加上()这样里面所有的数字都会被初始化为0，对于八大基本类型这样做都会进行初始化（可以不加()，但不会主动初始化），
对于其他复杂类型（自己创建的对象）必须加上()同时会进行初始化操作，这个知识点面试也有可能出现。*/
class Solution {
public:
	char findTheDifference(string s, string t) {
		int *map = new int[255]();
		for (int i = 0; i < s.length(); i++)
			map[s[i]]++;
		for (int i = 0; i < t.length(); i++)
		{
			map[t[i]]--;
			if (map[t[i]] < 0) return t[i];
		}
		return NULL;
	}
};